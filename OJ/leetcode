0001  排序或hash，好题(给定一个整数数组，从中找出两个数的下标，使得它们的和等于一个特定的数字)
0002  链表相加（给定两个链表分别代表两个非负整数。数位以倒序存储，并且每一个节点包含一位数字。将两个数字相加并以链表形式返回）
0003  滑动窗口（给定一个字符串，从中找出不含重复字符的最长子串的长度）
0004  Hard
0005  *动态规划或中心展开法或Manacher（最长回文子串）
0006  模拟，找到排布规律，经典做法（给定一个字符串，根据规则排布，根据排布输出）
0007  数字翻转，考虑溢出情况（给一个整数，输出它的翻转）
0008  字符串处理，考虑多种边界情况，经典题（实现atoi函数将字符串转换为整数）
0009  整数翻转，考虑整数溢出，好题（判断一个数是不是回文数）
0010  Hard
0011  *双指针法（找到两个高度，与x轴形成一个容器，使其包含最多的水）
0012  *模拟题，要知道罗马数字的原理（将一个整数转换为罗马数字）
0013  模拟题，如果当前字符小于下一个字符，则对结果贡献为负，否则贡献为正（罗马数字转换为整数）
0014  简单题（求若干字符串的最长公共前缀）
0015  *固定一个数，再用双指针法（n个数，选出3个相加和为0，输出所有情况）
0016  固定一个数，再用双指针法，再维护一个最优值用于更新（给定一个数组和目标元素，找出数组中的3个元素使其和最接近目标元素）
0017  *递归，最基础的dfs（根据手机按键，对于一个数字串，返回所有可能的字母组合）
      https://blog.csdn.net/lisonglisonglisong/article/details/45868539
0018  *固定两个数，再用双指针法 (n个数，选出4个相加和为目标元素，输出所有情况)
0019  *链表指针。由于不知道链表有多长，要使用两个相距那个单位的指针（给定链表，将倒数第n个元素删除后返回新的链表）
0020  栈（判断给出的string中，括号是不是一一对应的）
0021  *最简单的就是新开一个链表；递归方案返回两个链表中第一个更新的那个，经典题(给定两个有序的链表，求有序合并后的链表)
0022  *递归，递归出口是括号都用完了，加上左边括号数大于右边时添加右括号（给定一个数字n，代表括号的对数，求n对括号匹配的所有情况）
      https://blog.csdn.net/u012501459/article/details/46787097
0023  Hard
0024  *链表翻转，递归（给定一个链表，调换每两个相邻节点，并返回其头部。规定在O(1)的空间完成，并且不能修改值，只能修改节点）
      https://blog.csdn.net/nomasp/article/details/49803287
0025  Hard
0026  维护两个位置信息，指向结果位置和遍历到原数组的位置（对排好序的数列去重，返回不重复的数的个数n，只能使用常数的空间）
0027  *题解思路很巧妙，和上题一样维护两个位置信息，只需要O(n)时间（从数组中删除指定值的元素，并返回新数组的长度）
0028  kmp裸题（实现strStr()，返回在主字符串中出现的第一个子字符串的下标，如果不存在返回-1）
0029  *循环左移，达到乘法的效果，减少枚举次数；仅仅用被除数一直减除数会超时（求两个数的商，不能使用乘法，除法或者求模运算等等）
0030  Hard
0031  *按字典序生成下一个排列组合,经典题（实现“生成下一个排列”函数，如果是最后一行了，则重排成第一行）
      https://segmentfault.com/a/1190000007285442
0032  Hard
0033  *二分搜索，额外比较mid和right的大小（在循环递增数组中查询一个值的位置）
0034  *二分查找，第一个位置直接找x，第二个位置找x+1后，答案为前面的一个位置（在一个数组中，找给定数字出现的第一个位置和最后一个位置）
0035  二分查找，若不存在，直接返回left（在已排序的数组中找给定数字，若存在返回下标，若不存在，返回应该插入的位置）
0036  简单模拟题，不要遗漏检查小块中是否重复（判断一个残缺的数独是否合法，残缺位置用.表示）
0037  Hard
0038  *模拟题，以递推方式模拟（第一个数由“1”开始，从左往右读为“一个1”，所以第二个数为“11”，第三个数为“两个1”，即“21”）
0039  *dfs,第一眼没有看出来……，经典题（给定一个数组和一个目标数，数组中的每个数能重复使用，求加和为目标数的所有组合）
0040  dfs，去重的方法是判断当前数与上一个搜索到的数是否相同（一个有重复数字的数组和一个目标数，求从数组中取数加和为目标数的所有组合）
      读题失误，不是数组中每个数只能用一次，而是结果中不能有重复的数字。
0041  Hard
0042  Hard
0043  模拟题 (两个用字符串表示的数相乘，输出结果字符串形式)
0044  Hard
0045  Hard
0046  先排序，再生成下一个排列（给定一个数组，生成这组数构成的所有的全排列）
0047  和上题解法一样，先排序，再生成下一个排列（给出一个具有重复数字的数组，找出其所有不同的排列）
0048  模拟，水题（n*n的矩阵顺时针旋转90度）
0049  *HashMap,string和multiset映射（由相同字母组成的单词算一类，给数组中的单词分类）
0050  快速幂，防止溢出（求x的n次方）
0051  Hard
0052  Hard
0053  *动态规划，sum[i]表示从i开始的最大子串和，则有递推公式：sum[i] = max{A[i], A[i] + sum[i+1]}(求一个数组中最大子串和)
0054  简单模拟 (螺旋遍历输出一个m x n的数组,方向是上、右、下、左，依次循环)
0055
0056
0057  Hard
0058  简单模拟，从后往前，如果一开始就是空格则continue，如果遍历到字母后遍历到空格结束（给定一个含大小写字母和空格的串，求最后一个单词的长度）
0059  简单模拟（将1-n^2按螺旋顺序填入n*n的矩阵中）
0060  *枚举超时，找规律依据n个数的全排列数为n!，k/(n-1)!为结果的第一位，依次类推（给定n和k，求1-n的第k个全排列，n不大于9）
0061
0062
0063
0064
0065  Hard
0066
0067
0068  Hard
0069
0070
0071
0072  Hard
0073
0074
0075
0076  Hard
0077
0078
0079
0080
0081
0082
0083
0084  Hard
0085  Hard
0086
0087  Hard
0088
0089
0090
0091  *dp,递推公式容易想到，递推过程要分好类（给定字母到数字的映射，对于一个数，求有多少种可能的编码结果）
0092  *单链表翻转，理解了好久，一定要熟练（将链表[n,m]区间顺序翻转）
0093  暴力法，回溯法有点乱（给定一个只包含数字的字符串，返回所有合法的IP地址）
0094  递归，非递归方法不太好写，经典题（二叉树的中序遍历）
0095  *分治法，节点设置左右孩子属性（给定一个数n，求1到n这些数构成的所有二叉搜索树）
      https://blog.csdn.net/github_34514750/article/details/52211896
0096  *动态规划，总方案数为左子树的方案数乘右子树的方案数（给定一个数n，求1到n这些数可以构成多少棵二叉搜索树）
0097  Hard
0098  简单递归，节点左大于中大于右，中序遍历看是否递增，经典提（判断一棵二叉树是否为合法二叉搜索树）
0099  Hard
0100  *递归，好题，补习数据结构基础（判断两棵树是否是一样的）
0101
0102
0103
0104
0105
0106
0107
0108
0109
0110
0111
0112
0113
0114
0115  Hard
0116
0117
0118
0119
0120
0121
0122
0123  Hard
0124  Hard
0125
0126  Hard
0127
0128  Hard
0129
0130
0131
0132  Hard
0133
0134
0135  Hard
0136
0137
0138
0139
0140  Hard
0141
0142
0143
0144
0145  Hard
0146  Hard
0147
0148
0149  Hard
0150
0151
0152
0153
0154  Hard
0155
0156
0157
0158  Hard
0159  Hard
0160
0161
0162
0163
0164  Hard
0165
0166
0167
0168
0169
0170
0171
0172
0173
0174  Hard
0175
0176
0177
0178
0179
0180
0181
0182
0183
0184
0185  Hard
0186
0187
0188  Hard
0189
0190
0191
0192
0193
0194
0195
0196
0197
0198
0199
0200
0201
0202
0203
0204
0205
0206
0207
0208
0209
0210
0211
0212  Hard
0213
0214  Hard
0215
0216
0217
0218  Hard
0219
0220
0221
0222
0223
0224  Hard
0225
0226
0227
0228
0229
0230
0231
0232
0233  Hard
0234
0235
0236
0237
0238
0239  Hard
0240
0241
0242
0243
0244
0245
0246
0247
0248  Hard
0249
0250
0251
0252
0253
0254
0255
0256
0257
0258
0259
0260
0261
0262  Hard
0263
0264
0265  Hard
0266
0267
0268
0269  Hard
0270
0271
0272  Hard
0273  Hard
0274
0275
0276
0277
0278
0279
0280
0281
0282  Hard
0283
0284
0285
0286
0287
0288
0289
0290
0291  Hard
0292
0293
0294
0295  Hard
0296  Hard
0297  Hard
0298  *递归 (求二叉树最长连续上升子串的长度)
0299  hash（求两个字符串相同字符数和不同字符数）
0300  dp或二分查找，经典题（最长的连续上升的子序列，严格递增）
0301  Hard
0302  Hard
0303
0304
0305  Hard
0306
0307
0308  Hard
0309
0310
0311
0312  Hard
0313
0314
0315  Hard
0316  Hard
0317  Hard
0318
0319
0320
0321  Hard
0322
0323
0324
0325
0326
0327  Hard
0328
0329  Hard
0330  Hard
0331
0332
0333
0334
0335  Hard
0336  Hard
0337
0338
0339
0340  Hard
0341
0342
0343
0344
0345
0346
0347
0348
0349
0350
0351
0352  Hard
0353
0354  Hard
0355
0356
0357
0358  Hard
0359
0360
0361
0362
0363  Hard
0364
0365
0366
0367
0368
0369
0370
0371
0372
0373
0374
0375
0376
0377
0378
0379
0380
0381  Hard
0382
0383
0384
0385
0386
0387
0388
0389
0390
0391  Hard
0392
0393
0394
0395
0396
0397
0398
0399
0400
0401
0402
0403  Hard
0404
0405
0406
0407  Hard
0408
0409
0410  Hard
0411  Hard
0412
0413
0414
0415
0416
0417
0418
0419
0420  Hard
0421
0422
0423
0424
0425  Hard
0426  无题
0427  无题
0428  无题
0429  无题
0430  无题
0431  无题
0432  Hard
0433
0434
0435
0436
0437
0438
0439
0440  Hard
0441
0442
0443
0444
0445
0446  Hard
0447
0448
0449
0450
0451
0452
0453
0454
0455
0456
0457
0458
0459
0460  Hard
0461
0462
0463
0464
0465  Hard
0466  Hard
0467
0468
0469
0470  无题
0471  Hard
0472  Hard
0473
0474
0475
0476
0477
0478  无题
0479
0480  Hard
0481
0482
0483  Hard
0484
0485
0486
0487
0488  Hard
0489
0490
0491
0492
0493  Hard
0494
0495
0496
0497  无题
0498
0499  Hard
0500
0501
0502  Hard
0503
0504
0505
0506
0507
0508
0509  无题
0510  无题
0511  无题
0512  无题
0513
0514  Hard
0515
0516
0517  Hard
0518
0519  无题
0520
0521
0522
0523
0524
0525
0526
0527  Hard
0528  无题
0529
0530
0531
0532
0533
0534  无题
0535
0536
0537
0538
0539
0540
0541
0542
0543
0544
0545
0546  Hard
0547
0548
0549
0550  无题
0551
0552  Hard
0553
0554
0555
0556
0557
0558  无题
0559  无题
0560
0561
0562
0563
0564  Hard
0565
0566
0567
0568  Hard
0569  Hard
0570
0571  Hard
0572
0573
0574
0575
0576
0577
0578
0579  Hard
0580
0581
0582
0583
0584
0585
0586
0587  Hard
0588  Hard
0589  无题
0590  无题
0591  Hard
0592
0593
0594
0595
0596
0597
0598
0599
0600  Hard
0601  Hard
0602
0603
0604
0605
0606
0607
0608
0609
0610
0611
0612
0613
0614
0615  Hard
0616
0617
0618  Hard
0619
0620
0621
0622
0623
0624
0625
0626
0627
0628
0629  Hard
0630  Hard
0631  Hard
0632  Hard
0633
0634
0635
0636
0637
0638
0639  Hard
0640
0641  无题
0642  Hard
0643
0644  Hard
0645
0646
0647
0648
0649
0650
0651
0652
0653
0654
0655
0656  Hard
0657
0658
0659
0660  Hard
0661
0662
0663
0664  Hard
0665
0666
0667
0668  Hard
0669
0670
0671
0672
0673
0674
0675  Hard
0676
0677
0678
0679  Hard
0680
0681
0682
0683  Hard
0684
0685  Hard
0686
0687
0688
0689  Hard
0690
0691  Hard
0692
0693
0694
0695
0696
0697
0698
0699  Hard
0700  无题
0701  无题
0702  无题
0703  无题
0704  无题
0705  无题
0706  无题
0707  无题
0708  无题
0709  无题
0710  无题
0711  Hard **dfs，vector数组保存连通块的向量信息，set去重(图中有若干连通块，经过旋转或翻转操作形状相同的连通块算同一种，求有多少种连通块)
      https://blog.csdn.net/magicbean2/article/details/79282937
0712  *dp，最长公共字串变种，好题（给定字符串s1, s2。删除其中的一些字符使得两字符串相等，删除字符的代价是被删字符ASCII之和，求最小代价。）
0713  *滑动窗口，经典题（给定数组nums，求其中乘积小于k的连续子数组的个数）
      note：包含当前元素的连续子数组个数刚好等于当前子数组长度（假设数组是 1，2，3，4 ,则包含4的子集合分别是{4}，{3，4}，{2，3，4}，{1，2，3，4}）
0714  *dp(给定一组股票价格prices，卖出股票时手续费fee，求一系列买入卖出操作的最大收益)
      https://blog.csdn.net/H12590400327/article/details/78820755
0715  Hard
0716  Hard
0717
0718
0719  Hard
0720
0721
0722
0723
0724
0725
0726  Hard
0727  Hard
0728
0729
0730  Hard
0731
0732  Hard
0733
0734
0735
0736  Hard
0737
0738
0739
0740
0741  Hard
0742
0743
0744
0745  Hard
0746
0747
0748
0749  Hard
0750
0751
0752
0753  Hard
0754
0755
0756
0757  Hard
0758
0759  Hard
0760
0761  Hard
0762
0763
0764
0765  Hard
0766
0767
0768  Hard
0769
0770  Hard
0771
0772  Hard
0773  Hard
0774  Hard
0775
0776
0777
0778  Hard
0779
0780  Hard
0781
0782  Hard
0783
0784
0785
0786  Hard
0787
0788
0789
0790
0791
0792
0793  Hard
0794
0795
0796
0797
0798  Hard
0799
0800  模拟，字符串水题（找与当前16进制串距离最近的串）
0801  *dp，好题（两个长度相等的数组，可交换相同位置，求使两个数组均递增所需要交换的最小次数）
0802  *图的染色问题，好题 （判断节点是否不在环上，若后继节点在环上则该节点也在环上）
0803  Hard **并查集（一个矩阵中1表示砖块，与第一行砖块相连的砖块不下落，相邻砖块至少有一块不下落则也不下落。拿掉一块砖块，问几块受到影响）
      https://blog.csdn.net/brazy/article/details/79678332
0804  Map + Set（将字母翻译成莫尔斯码，求不同莫尔斯码的个数）
0805  Hard *dp，背包，经典题（给定整数数组A，求是否可以将A分成平均数相等的两个非空子数组）
0806  模拟，水题（信纸宽度100，告诉每个字母宽度，给一个字符串，问要写几行和最后一行的长度）
0807  模拟，思维水题（填充n*m的矩阵，使每行每列的最大值均不变，求最大填充数）
0808  概率dp，比较裸 （四种倒水操作各有一个概率，算A先空的概率和同时空的概率）
0809  模拟，字符串水题 （子串重复若干字母是否能构成主串）
0810  Hard 简单博弈 （从一堆数中每次取一个数，取到使异或和为0的人输）
0811
0812
0813
0814
0815  Hard
0816
0817
0818
0819
0820

